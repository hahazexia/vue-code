# 组件化

Vue.js 另⼀个核⼼思想是组件化。所谓组件化，就是把⻚⾯拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图⽚等资源放在⼀起开发和维护。组件是资源独⽴的，组件在系统内部可复⽤，组件和组件之间可以嵌套。

我们在⽤ Vue.js 开发实际项⽬的时候，就是像搭积⽊⼀样，编写⼀堆组件拼装⽣成⻚⾯。在 Vue.js 的官⽹中，也是花了⼤篇幅来介绍什么是组件，如何编写组件以及组件拥有的属性和特性。

那么在这⼀章节，我们将从源码的⾓度来分析 Vue 的组件内部是如何⼯作的，只有了解了内部的⼯作原理，才能让我们使⽤它的时候更加得⼼应⼿。

接下来我们会⽤ Vue-cli 初始化的代码为例，来分析⼀下 Vue 组件初始化的⼀个过程。

```js
import Vue from 'vue'
import App from './App.vue'

var app = new Vue({
  el: '#app',
  // 这⾥的 h 是 createElement ⽅法
  render: h => h(App)
})
```

这段代码相信很多同学都很熟悉，它和我们上⼀章相同的点也是通过 render 函数去渲染的，不同的这次通过 createElement 传的参数是⼀个组件⽽不是⼀个原⽣的标签，那么接下来我们就开始分析这⼀过程。

## createComponent

上⼀章我们在分析 createElement 的实现的时候，它最终会调⽤ _createElement ⽅法，其中有⼀段逻辑是对参数 tag 的判断，如果是⼀个普通的 html 标签，像上⼀章的例⼦那样是⼀个普通的 div，则会实例化⼀个普通 VNode 节点，否则通过 createComponent ⽅法创建⼀个组件 VNode。

```js
if (typeof tag === 'string') { // 如果 tag 是普通的 html 标签, 就新建一个 vnode
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {// 如果是 component
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else { // 如果不认识的标签名
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {// 否则创建 component
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
```

在我们这⼀章传⼊的是⼀个 App 对象，它本质上是⼀个 Component 类型，那么它会⾛到上述代码的 else 逻辑，直接通过 createComponent ⽅法来创建 vnode 。所以接下来我们来看⼀下 createComponent ⽅法的实现，它定义在 `src/core/vdom/create-component.js` ⽂件中：

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void { // 此方法用于创建 component 的 vnode
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base
  // baseCtor 就是 Vue 构造函数
  // 在 src/core/global-api/index 中定义了 Vue.options._base = Vue
  // 在 Vue.prototype._init 中会把 Vue.options 合并到 vm.$options 中


  // plain options object: turn it into a constructor
  if (isObject(Ctor)) { // 如果 Ctor 是个对象，构造⼦类构造函数。Vue.extend 定义在 src/core/global-api/extend 中
    Ctor = baseCtor.extend(Ctor)
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') { // 如果子构造器生成失败，报错
    if (process.env.NODE_ENV !== 'production') {
      warn(`Invalid Component definition: ${String(Ctor)}`, context)
    }
    return
  }

  // async component
  // 异步组件逻辑
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {

      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // extract props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  const listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data) // 安装组件钩⼦函数

  // return a placeholder vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  ) // 实例化 vnode

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  if (__WEEX__ && isRecyclableComponent(vnode)) {
    return renderRecyclableComponentTemplate(vnode)
  }

  return vnode
}
```

可以看到， createComponent 的逻辑也会有⼀些复杂，但是分析源码⽐较推荐的是只分析核⼼流程，分⽀流程可以之后针对性的看，所以这⾥针对组件渲染这个 case 主要就 3 个关键步骤：构造⼦类构造函数，安装组件钩⼦函数，实例化 vnode 。

### 构造⼦类构造函数

```js
const baseCtor = context.$options._base
// plain options object: turn it into a constructor
if (isObject(Ctor)) {
  Ctor = baseCtor.extend(Ctor)
}
```

我们在编写⼀个组件的时候，通常都是创建⼀个普通对象，还是以我们的 App.vue 为例，代码如下：

```js
import HelloWorld from './components/HelloWorld'
export default {
  name: 'app',
  components: {
    HelloWorld
  }
}
```

这⾥ export 的是⼀个对象，所以 createComponent ⾥的代码逻辑会执⾏到 baseCtor.extend(Ctor) ，在这⾥ baseCtor 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 `src/core/global-api/index.js` 中的 initGlobalAPI 函数有这么⼀段逻辑：

```js
// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue
```

细⼼的同学会发现，这⾥定义的是 Vue.option ，⽽我们的 createComponent 取的是 context.$options ，实际上在 `src/core/instance/init.js` ⾥ Vue 原型上的 _init 函数中有这么⼀段逻辑：

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

这样就把 Vue 上的⼀些 option 扩展到了 vm.$option 上，所以我们也就能通过 vm.$options._base 拿到 Vue 这个构造函数了。 mergeOptions 的实现我们会在后续章节中具体分析，现在只需要理解它的功能是把 Vue 构造函数的 options 和⽤户传⼊的 options 做⼀层合并，到 vm.$options 上。

在了解了 baseCtor 指向了 Vue 之后，我们来看⼀下 Vue.extend 函数的定义，在 `src/core/global-api/extend.js` 中。

```js
/**
   * Class inheritance
   */
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    const Super = this // 就是 Vue
    const SuperId = Super.cid
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    // 将生成好的子类构造器缓存优化，下次传入同样的参数就不用再次生成了

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name) // 判断组件 name 属性是否合法，不合法就会报错
    }

    const Sub = function VueComponent (options) { // 创建了一个子构造函数，里面也是调用了 Vue.prototype._init
      this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype) // Sub 构造函数继承自 Vue
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    ) // 自身的 options 和 Vue.optinos 做了合并
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub // 将 Sub 构造函数缓存
    return Sub
  }
```

Vue.extend 的作⽤就是构造⼀个 Vue 的⼦类，它使⽤⼀种⾮常经典的原型继承的⽅式把⼀个纯对象转换为⼀个继承于 Vue 的构造器 Sub 并返回，然后对 Sub 这个对象本⾝扩展了⼀些属性，如扩展 options 、添加全局 API 等；并且对配置中的 props 和 computed 做了初始化⼯作；最后对于这个 Sub 构造函数做了缓存，避免多次执⾏ Vue.extend 的时候对同⼀个⼦组件重复构造。

这样当我们去实例化 Sub 的时候，就会执⾏ this._init 逻辑再次⾛到了 Vue 实例的初始化逻辑，实例化⼦组件的逻辑在之后的章节会介绍。

```js
const Sub = function VueComponent (options) {
  this._init(options)
}
```

### 安装组件钩⼦函数

```js
// install component management hooks onto the placeholder node
installComponentHooks(data)
```

我们之前提到 Vue.js 使⽤的 Virtual DOM 参考的是开源库 snabbdom，它的⼀个特点是在 VNode 的 patch 流程中对外暴露了各种时机的钩⼦函数，⽅便我们做⼀些额外的事情，Vue.js 也是充分利⽤这⼀点，在初始化⼀个 Component 类型的 VNode 的过程中实现了⼏个钩⼦函数：

```js
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = { // 组件钩子 init prepatch insert destroy
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}

const hooksToMerge = Object.keys(componentVNodeHooks)

function installComponentHooks (data: VNodeData) { // 初始化组件钩子
  const hooks = data.hook || (data.hook = {})
  for (let i = 0; i < hooksToMerge.length; i++) { // 遍历四个钩子 init prepatch insert destroy
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      // 将 VnodeData 的 hook 也就是用户自定义的 hook 和 vnode 默认的 hook 合并，钩子触发后会依次执行
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}


```

整个 installComponentHooks 的过程就是把 componentVNodeHooks 的钩⼦函数合并到 data.hook 中，在 VNode 执⾏ patch 的过程中执⾏相关的钩⼦函数，具体的执⾏我们稍后在介绍 patch 过程中会详细介绍。这⾥要注意的是合并策略，在合并过程中，如果某个时机的钩⼦已经存在 data.hook 中，那么通过执⾏ mergeHook 函数做合并，这个逻辑很简单，就是在最终执⾏的时候，依次执⾏这两个钩⼦函数即可。

### 实例化 VNode

```js
 // return a placeholder vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  ) // 实例化 vnode
```

最后⼀步⾮常简单，通过 new VNode 实例化⼀个 vnode 并返回。需要注意的是和普通元素节点的vnode 不同，组件的 vnode 是没有 children 的，这点很关键，在之后的 patch 过程中我们会再提。

### 总结

这⼀节我们分析了 createComponent 的实现，了解到它在渲染⼀个组件的时候的 3 个关键逻辑：构造⼦类构造函数，安装组件钩⼦函数，实例化 vnode。createComponent 后返回的是组件 vnode ，它也⼀样⾛到 vm._update ⽅法，进⽽执⾏了 patch 函数，我们在上⼀章对 patch 函数做了简单的分析，那么下⼀节我们会对它做进⼀步的分析。

## patch
