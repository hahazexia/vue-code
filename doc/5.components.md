# 组件化

以下面一个最简单的代码为例，来分析组件化是怎么实现的：

```js
import Vue from 'vue'
import App from './App.vue'
var app = new Vue({
    el: '#app',
    render: h => h(App)
    // 此处的 h 参数就是 createElement 方法
})
```

回忆：$mount 其实就是先去获取到 template 对应的 dom 元素，然后根据 dom 生成 render 方法，（此处 beforeMount）然后调用 _render 生成 vnode。生成 vnode 的时候，其实依靠的是 createElement 方法，里面调用了 _createElement。_createElement 中判断 tag 参数，如果不是字符串，这时候就说明参数是一个 component，就会调用 createComponent。

```js
vnode = createComponent(tag, data, context, children)
```

## createComponent

createComponent 在 `src/core/vdom/create-comonent`

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void { // 此方法用于创建 component 的 vnode
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base
  // baseCtor 就是 Vue 构造函数
  // 在 src/core/global-api/index 中定义了 Vue.options._base = Vue
  // 在 Vue.prototype._init 中会把 Vue.options 合并到 vm.$options 中


  // plain options object: turn it into a constructor
  if (isObject(Ctor)) { // 如果 Ctor 是个对象，就调用 Vue.extend() 对于这个组件创建一个继承自 Vue 的子构造器。Vue.extend 定义在 src/core/global-api/extend 中
    Ctor = baseCtor.extend(Ctor)
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') { // 如果子构造器生成失败，报错
    if (process.env.NODE_ENV !== 'production') {
      warn(`Invalid Component definition: ${String(Ctor)}`, context)
    }
    return
  }

  // async component
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // extract props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  const listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // install component management hooks onto the placeholder node
  // 安装组件钩子
  installComponentHooks(data)

  // return a placeholder vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )
  // 生成 vnode。component 的 vnode 和普通 vnode 不一样，第三个参数 children 是 undefined。也就是说 component 对应的 vnode 的 children 是空。但是它有 componentOptions 是一个对象，里面有 children

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  if (__WEEX__ && isRecyclableComponent(vnode)) {
    return renderRecyclableComponentTemplate(vnode)
  }

  return vnode
}
```

总结： createComponent 用于创建 component 的 vnode。它主要做了三件事：构造⼦类构造函数，安装组件钩⼦函数和实例化 vnode。

其中构造子类构造函数的时候使用的是 Vue.extend 定义在 `src/core/global-api/extend` 中

```js
Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    const Super = this // 就是 Vue
    const SuperId = Super.cid
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {}) // 将生成好的子类构造器缓存优化，下次传入同样的参数就不用再次生成了
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name) // 判断组件 name 属性是否合法，不合法就会报错
    }

    const Sub = function VueComponent (options) { // 创建了一个子构造函数，里面也是调用了 Vue.prototype._init
      this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype) // Sub 构造函数继承自 Vue
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    ) // 自身的 options 和 Vue.optinos 做了合并
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub // 将 Sub 构造函数缓存
    return Sub
  }
}
```

## patch

```js
// main.js

import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h => h(App),
}).$mount('#app')


// App.vue
<template>
  <div id="app">
    <img alt="Vue logo" src="./assets/logo.png">
    <HelloWorld msg="Welcome to Your Vue.js App"/>
  </div>
</template>

<script>
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'App',
  components: {
    HelloWorld
  }
}
</script>

// HelloWorld.vue

<template>
  <div class="hello">
  ......
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  }
}
</script>


```

* 首先是下面 main.js 中的根组件初始化

```js
new Vue({
  render: h => h(App),
}).$mount('#app')
```

走完 Vue.prototype._init 后，会走到 Vue.prototype.$mount 然后调用 mountComponent，在 mountComponent 中会给 vm.$el 赋值为 div#app。

* 因为我们已经在 option 中提供了 render 方法，所以会走到 mountComponent 中这一句：

```js
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```

然后 updateComponent 会传递给 Watcher 为参数，创建新的渲染 Watcher 实例。

* 然后渲染 Watcher 会触发刚才的 updateComponent 中的 vm._render()，也就是 Vue.prototype._render。

* 接着 Vue.prototype._render 里会走到这一句

```js
  vnode = render.call(vm._renderProxy, vm.$createElement);
```
render 就是在根组件直接传入的 render: h => h(App)，而这个 h 参数就是 vm.$createElement。也就是：

```js
vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
```

所以最后调用 createElement 的时候只有 vm 和 a 参数，a 参数就是 App.vue 组件。App.vue 组件已经被 webpack 的 loader 处理成了带有 render 参数的一个对象。

* 下来调用 _createElement。

```js
_createElement(context, tag, data, children, normalizationType)
```

这时候 context 参数是根组件 vm，tag 是 App.vue 组件。所以这时候 tag 参数不是字符串，会调用 createComponent去继续创建 App.vue 组件

```js
vnode = createComponent(tag, data, context, children);
```

这时候一样的，createComponent 接收的 tag 参数是 App.vue 组件对象，context 参数是根组件 vm。

* createComponent 中走到下面这段逻辑

```js
  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
```

baseCtor 其实就是 Vue 构造函数，而这里的 Ctor 就是接收的参数 tag，就是 App.vue 组件对象，它是一个对象，所以就调用 Vue.extend 创建一个继承自 Vue 的子类构造函数 Sub 然后赋值给 Ctor。

刚进入 createComponnet 的时候接收的 data 参数是个空对象，走到下面这个逻辑：

```js
 installComponentHooks(data);
```

installComponentHooks 会将 4 个 组件的钩子函数加入到 data.hook 中。然后 new 一个组件 vnode：

```js
const vnode = new VNode(
  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
  data, undefined, undefined, undefined, context,
  { Ctor, propsData, listeners, tag, children },
  asyncFactory
)
// 生成 vnode。component 的 vnode 和普通 vnode 不一样，第三个参数 children 是 undefined。也就是说 component 对应的 vnode 的 children 是空。但是它有 componentOptions 是一个对象，里面有 children
```

后面就会知道这个组件 vnode 是一个占位符 vnode。

* 这时候这个 App.vue 对应的组件 vnode 返回了，Vue.prototype._render 也执行完返回了，

```js
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```

返回到这里，作为 vm._render() 的结果，然后作为参数传给 vm._update() 执行。

* Vue.prototype._update 执行的时候要注意这里

```js
var vm = this;
var prevEl = vm.$el;
var prevVnode = vm._vnode;
var restoreActiveInstance = setActiveInstance(vm);
vm._vnode = vnode;
```

这时候的 vm 还是 根组件，所以 prevVnode 为空，然后调用 setActiveInstance 将全局变量 activeInstance 设置为当前根组件 vm。

然后把 vm._vnode 赋值为 之前 vm._render() 生成的 占位符 vnode，对应 App.vue 组件。然后执行 __patch__

```js
if (!prevVnode) {
  // initial render
  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
}
```

* patch 方法

```js
patch (oldVnode, vnode, hydrating, removeOnly) {
```

oldVnode 是 div#app 元素，vnode 是 App.vue 组件对应的 占位符 vnode。

```js
oldVnode = emptyNodeAt(oldVnode);
```

根据 div#app 元素生成空的 vnode 节点。

```js
var oldElm = oldVnode.elm; // div#app
var parentElm = nodeOps.parentNode(oldElm); // div#app 的父级 body 元素
```

接下来调用 createElm 方法

```js
createElm(
  vnode,
  insertedVnodeQueue,
  // extremely rare edge case: do not insert if old element is in a
  // leaving transition. Only happens when combining transition +
  // keep-alive + HOCs. (#4590)
  oldElm._leaveCb ? null : parentElm,
  nodeOps.nextSibling(oldElm)
);
```

* createElm 

```js
function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

```

vnode 是 App.vue 占位符 vnode，parentElm 是 body 元素，refElm 是个文本节点换行符。这时候走到 createComponent 这句

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  var i = vnode.data;
  if (isDef(i)) {
    var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      i(vnode, false /* hydrating */);
    }
    // after calling the init hook, if the vnode is a child component
    // it should've created a child instance and mounted it. the child
    // component also has set the placeholder vnode's elm.
    // in that case we can just return the element and be done.
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue);
      insert(parentElm, vnode.elm, refElm);
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
      }
      return true
    }
  }
}
```

会去执行 vnode.data.hook.init()，也就是当时 installComponentHooks 的 4 个组件钩子函数中的 init。

```js
init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
```

然后会调用 createComponentInstanceForVnode, vnode 是 App.vue 占位符 vnode，activeInstance 是全局变量当前激活的实例，根组件 vm 实例。

```js
function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode, // App.vue 占位符 vnode
    parent: parent // 根组件 vm 实例
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options) // 调用当时为 App.vue 组件创建的 Sub 子类构造函数
}
```

Sub 子类构造函数又走到了 Vue.prototype._init 里，这时候初始化的是 App.vue 这个组件了。也就是先初始化根组件，然后初始化根组件的子组件 App.vue。

```js
if (options && options._isComponent) {
  // optimize internal component instantiation
  // since dynamic options merging is pretty slow, and none of the
  // internal component options needs special treatment.
  initInternalComponent(vm, options)
}
```

Vue.prototype._init 的时候 options._isComponent 为 true，走到了 initInternalComponent 里。这时候 vm 是 Sub 子类的实例。options 是刚才 createComponentInstanceForVnode 中传入的 

```js
var options = {
  _isComponent: true,
  _parentVnode: vnode, // App.vue 占位符 vnode
  parent: parent // 根组件 vm 实例
};
```

下面是 initInternalComponent，用于给 Sub 的实例的 options 添加一些属性

```js
function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode; // App.vue 占位符 vnode
  opts.parent = options.parent; // 根组件 vm 实例
  opts._parentVnode = parentVnode; // App.vue 占位符 vnode

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}
```

_init 中的 initLifecycle 调用后，会将子组件的 $parent 指向子组件的 options.parent，同时父组件的 $children 也 push 了子组件， 这样就建立了父子级的关系。

```js
export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent // 父组件
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm) // vm 是子组件，push 到父组件的$children中
  }

  vm.$parent = parent // 子组件$parent指向父组件
```

继续往下走，

```js
if (vm.$options.el) {
  vm.$mount(vm.$options.el)
}
```

这时候 不会走 $mount，因为这时候是 App.vue 组件，用 Sub 子类生成的，还没有 el 参数

_init 结束。Sub 构造结束，回到 createComponentInstanceForVnode。

```js
return new vnode.componentOptions.Ctor(options)
```

然后回到 init 钩子函数：

```js
init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating); // 在这里 $mount
    }
  },
```

可以看到 createComponentInstanceForVnode 生成的 Sub 子类的实例就是 App.vue 对应的 Vue 实例，赋值给 App.vue 占位符 vnode 的 componentInstance 属性，然后调用其 $mount。

* mountComponent 中又走到了下面的逻辑：

```js
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```

这时候的 vm 是 App.vue 实例了。然后 updateComponent 传递给新的渲染 Watcher，里面会触发 Vue.prototype._render

* Vue.prototype._render 会把 vm.$vnode 赋值为占位符 vnode 

```js
vm.$vnode = _parentVnode;
```

然后 _render 的后续流程是根据 App.vue 的占位符 vnode 生成渲染 vnode。

此刻 App.vue 实例的 render 函数是从 template 编译而来，就使用 vm._c

```js
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { attrs: { id: "app" } },
    [
      _c("img", {
        attrs: { alt: "Vue logo", src: require("./assets/logo.png") }
      }),
      _c("HelloWorld", { attrs: { msg: "Welcome to Your Vue.js App" } })
    ],
    1
  )
}
```
我们发现调用了三次 vm._c ，第一次生成 div#app，然后是 img，然后是 HelloWorld 组件。因为是组件，执行 _createElement 的时候会走下面

```js
vnode = createComponent(Ctor, data, context, children, tag);
```

这时候就回去调用 createComponent 创建 HelloWorld 组件的占位符 vnode，之后的流程就和创建 App.vue 的时候类似了。



* 根组件初始化
* Vue.prototype._init
* mountComponent
* updateComponent 传给 new Watcher()
* updateComponent 触发，执行 vm._render()
* Vue.prototype._render
* createElement
* _createElement
* createComponent，开始去创建 App.vue 的占位符 vnode
* 调用 Vue.extend 创建App组件的构造函数 Sub
* installComponentHooks 初始化组件 hook
* 生成 App.vue 的占位符 vnode，Vue.prototype._render 到这里执行结束，回到 updateComponent 中的逻辑
* vm._update()，vm 是根组件实例
* __patch__，patch
* createElm
* patch 中的 createComponent 方法
* 执行 vnode.data.hook.init()
* createComponentInstanceForVnode 中调用 Sub 子类构造函数创建 App.vue 组件的 vm 实例
* Vue.prototype._init 这时候是初始化 App.vue 组件
* Sub 构造 App 组件实例结束，回到 createComponentInstanceForVnode，然后回到 vnode.data.hook.init()
* init 最后调用 child.$mount，开始 $mount App 组件
* mountComponent
* updateComponent 传给 new Watcher()
* updateComponent 触发，执行 vm._render()
* Vue.prototype._render 中调用通过 template 模板编译而来的 render 函数，其中调用多次 vm._c
* vm._c 会调用 createElement _createElement
* 如果 vm._c 处理的是普通节点，那么就会生成 vnode 然后等待 _update 中的 patch 流程转换 vnode 为真实 dom
* 如果 vm._c 处理的是组件，那么又会走到 createComponent 去生成占位符 vnode

## 配置合并

有两次配置合并：外部调用场景，new Vue 的时候；组件场景的配置合并，组件初始化的时候。

首先看看 mixin 是做什么的，在 `src/core/global-api/mixin.js`

```js
export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin) // mergeOptions 把 mixin 传入的参数合并到 Vue.options
    return this
  }
}

```

mixin 方法其实就是调用 mergeOptions 方法把传入的参数合并到 Vue.options 上。

接着我们去看两次配置合并的代码，在 `src/core/instance/init.js` 的 Vue.prototype._init 中：

```js
if (options && options._isComponent) {
  // 组件vnode patch 的时候会调用组件内部hook的init，然后会调用到子类构造函数Sub，Sub会调用 this._init走到这里，这时候的vm是Sub子类的实例
  // optimize internal component instantiation
  // since dynamic options merging is pretty slow, and none of the
  // internal component options needs special treatment.
  initInternalComponent(vm, options)
} else {
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {}, // 用户 new Vue 的时候传入的 options
    vm
  )
  // 第一次 new Vue 的时候会调用 mergeOptions 合并配置
}
```

new Vue 的时候使用 mergeOptions 将 Vue.options 和用户传入的 options 合并作为新实例的 $options。而组件的 options 合并调用 initInternalComponent 处理。

mergeOptions 在 `src/core/util/options.js` 中

```js
export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
): Object {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)
  }

  if (typeof child === 'function') {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    // 循环 child 的 extends 和 mixins 属性，将其中的 option 调用 mergeOptions 合并入 parent
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  let key
  for (key in parent) { // 遍历 parent ，调用 mergeField 将 parent 中 option 合并到 options 变量中
    mergeField(key)
  }
  for (key in child) { // 遍历 child ，如果 parent 没有这个 key，调用 mergeField 将其合并到 options 变量中
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    // 通过不同的 key 拿到不同的 strats 函数
    // strats 是对各种不同的 option 定义了对应的合并策略
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

mergeOptions 其实就是根据 options 的不同 key 值执行不同的合并策略将其合并到一个空对象上，然后将这个对象返回。

以合并生命周期的策略为例子：

```js
function mergeHook (
  parentVal: ?Array<Function>,
  childVal: ?Function | ?Array<Function>
): ?Array<Function> { // 生命周期的合并，最后会返回一个数组
  const res = childVal
    ? parentVal
      ? parentVal.concat(childVal) // 子和父都定义了就把子和父连接成数组
      : Array.isArray(childVal) // 子定义了就看父，如果父没有定义，就判断子是不是数组，如果是数组直接返回，如果不是数组就变成一个数组
        ? childVal
        : [childVal]
    : parentVal // 子没有定义，直接取父
  return res
    ? dedupeHooks(res)
    : res
}
```

可以看出生命周期的合并将多个同名的生命周期合并成了函数组成的数组返回，当生命周期执行时，就是将这个数组里的函数依次执行。


以下面这个简单例子来分析：


```js
import Vue from 'vue'

let childComp = {
  template: '<div>{{msg}}</div>',
  created() {
    console.log('child created')
  },
  mounted() {
    console.log('child mounted')
  },
  data() {
    return {
      msg: 'Hello Vue'
    }
  }
}

Vue.mixin({
  created() {
    console.log('parent created')
  }
})

let app = new Vue({
  el: '#app',
  render: h => h(childComp)
})
```

* 先执行 Vue.mixin `src/core/global-api/mixin.js`

```js
export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin) // mergeOptions 把 mixin 传入的参数合并到 Vue.options
    return this
  }
}

```

然后进入 mergeOptions，将 mixin 传入的 created 合并到 Vue.options，这时候 Vue.options.created 就是一个 `[f]` 函数数组

* 然后 new Vue 走到 Vue.prototype._init，又走到了

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {}, // 用户 new Vue 的时候传入的 options
  vm
)
```

会将 Vue.options 和 new Vue 传入的 options 合并作为 vm.$options，这样 vm.$options 也和 Vue.options 一样拥有了 created 生命周期函数的函数数组

* 接着初始化子组件的时候调用了 Vue.extend 去生成 Sub 子类构造函数，其中调用了 mergeOptions 将子组件的 options 和 Vue.options 合并作为 Sub.options

```js
 Sub.options = mergeOptions(
    Super.options,
    extendOptions
  );
```

子组件的 options 也有 created 生命周期钩子，经过 mergeOptions 合并后，created 的值为 [f, f]，父组件的 created 在前，子组件的 created 在后

然后接着会调用 Vue.prototype._init 初始化子组件 Sub 实例，进入 initInternalComponent 方法，它会为 Sub 子组件实例生成 vm.$options 属性，继承自 Sub.options。

## 生命周期

callHook 用来调用生命周期钩子函数，定义在 `src/core/instance/lifecycle.js`

```js
export function callHook (vm: Component, hook: string) { // 调用生命周期钩子函数
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const handlers = vm.$options[hook] // vm.$options.hook 是合并后的 hook 组成的数组
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) { // 遍历钩子函数组成的数组，然后调用
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) { // 如果 vm 实例上 $on 监听了 hook 生命周期钩子事件，就 $emit 发送该事件触发回调函数
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```

* beforeCreate 和 created

去看 Vue.prototype._init 中触发的两个生命周期钩子

```js
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm) // 初始化 data 对象，并添加响应式
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

可以看出 beforeCreate 和 created 的区别，beforeCreate 的时候是拿不到 data props methods 数据的，如果想要通过 this 拿到实例上的数据，需要在 created 里操作，因为初始化 data props methods 是在 initState(vm) 这一步做的。


* beforeMount 和 mounted

mount 挂载的流程首先会执行 `src/core/instance/lifecycle.js` 中的 mountComponent，mountComponent 中调用 callHook(vm, 'beforeMount')。而嵌套多个组件的时候，走到子组件的 mount 时，又会执行 mountComponent，所以父子组件的 beforeMount 的顺序是 先父后子。

如果没有嵌套的子组件，那么等到 _render _update 流程走完之后就会 callHook(vm, 'mounted')。

如果有多个嵌套子组件的话，就会是如下流程：

* 父组件 mountComponent
* 父组件 callHook(vm, 'beforeMount')
* _render
* vm.$createElement
* _createElement
* createComponent
* installComponentHooks(data) 为 data 添加组件钩子
* createComponent 生成占位符 vnode 返回
* 父组件 _update
* 父组件 patch
* patch createElm
* patch createComponent
* 调用 installComponentHooks 添加的 init 钩子
* init 钩子会调用 Sub 子组件构造函数创建子组件实例，然后调用子组件 $mount
* 当子组件的 mount 流程走完后，会触发操作将子组件 vnode 插入 insertedVnodeQueue，子组件 vnode 会先插入insertedVnodeQueue
* 等到子组件 mount 走完了，patch 流程的最后会触发 invokeInsertHook ，遍历 insertedVnodeQueue，触发所有子组件的 insert 钩子，其中会 callHook(componentInstance, 'mounted')，触发 mounted 生命周期

所以根据上面的分析，mounted 的顺序是 先子后父

* beforeUpdate 和 updated

mount 流程中的 mountComponent，其中会 new 一个 Watcher，传入了一个对象参数：

```js
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
```

这个参数中的 before 方法会在 `src/core/observer/scheduler.js` 中的 flushSchedulerQueue 方法中被调用。nextTick 的时候会执行 flushSchedulerQueue。

Watcher 更新完之后会执行 callHook(vm, 'updated')。

* beforeDestroy 和 destroyed

销毁流程会触发 Vue.prototype.$destroy，beforeDestroy 先父后子，beforeDestroy 触发后会调用 vm.__patch__(vm._vnode, null)，第二个参数传 null 会触发销毁操作，其中会遍历子组件，然后调用子组件的 $destroy，所以 destroyed 是先子后父。

## 组件注册

组件注册包括全局注册和局部注册两种方式。

* 全局注册调用 `Vue.component`，定义在 `src/core/global-api/assets` 中

```js
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') { // 开发环境下对组件名做校验
          validateComponentName(id)
        }
        if (type === 'component' && isPlainObject(definition)) { // 如果调用的是 Vue.component 组件注册，并且 definition 是对象
          definition.name = definition.name || id // 如果定义没有 name ，就取 id
          definition = this.options._base.extend(definition) // 调用 Vue.extend 生成子组件构造函数
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        this.options[type + 's'][id] = definition // 在 Vue.options 上加入对应的定义
        return definition
      }
    }
  })
```

可以看到调用 Vue.extend 生成子组件的构造函数后，会将其挂到 `Vue.options.components[id]` 上，那么是什么时候使用呢？

是在 _render 触发后调用 createElement 的时候使用，createElement 最终会调用 _createElement 生成 Vnode，_createElement 中有这样一句：

```js
 else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {// 如果是 component
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    }
```

这里会调用 resolveAsset 去在 `Vue.options.components` 上找这个标签名对应的组件。注意这里的 context.$options 是经过 mergeOptions 合并而来，所以包含了 Vue.options。

```js
export function resolveAsset (
  options: Object,
  type: string,
  id: string,
  warnMissing?: boolean
): any {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  const assets = options[type]
  // check local registration variations first
  if (hasOwn(assets, id)) return assets[id] // 如果options[type][id] 存在直接返回
  const camelizedId = camelize(id) // camelize('aa-bb-cc') "aaBbCc" 把连字符写法转换成驼峰写法
  if (hasOwn(assets, camelizedId)) return assets[camelizedId] // 用驼峰写法继续找options[type][id] 是否存在
  const PascalCaseId = capitalize(camelizedId) // 首字母大写的驼峰写法
  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId] // 首字母大写的驼峰写法是否存在
  // fallback to prototype chain
  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    )
  }
  return res
}

```

找到了对应的子构造函数就传递给 createComponent 作为参数去创建组件 vnode，然后挂在 vnode.componentOptions 上面，等待后续占位符 vnode 走到 patch 流程后调用组件钩子 init 的时候会被触发，创建子组件的实例。


* 局部注册组件其实走的是 Vue.extend 生成了 Sub 子构造函数，并且 Sub.options  是 mergeOptions 合并了 Super.options 和 extendOptions。然后走到 _init 的时候会走到 initInternalComponent，有这样一句：

```js
const opts = vm.$options = Object.create(vm.constructor.options)
```

子组件实例的 $options 是继承自 Sub.options，因此，resolveAsset 的时候通过 vm.$options.components 就能够拿到子组件的构造器。

## 异步组件

### 工厂函数

异步组件还是调用 Vue.component 注册的，他和普通组件的区别是，第二个参数不是一个对象，而是一个函数：

```js
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})
```

所以还是会走到 Vue.component 的逻辑，Vue.component 中对第二个参数 definition 是函数的情况没有做处理，直接将 definition 挂到 `Vue.options.components[id]` 上。

后面当创建 vnode 的时候，会走到 `src/core/vdom/create-element.js` 中的 _createElement，会调用 resolveAsset 从 Vue.options.components 上找到对应的这个函数作为 Ctor，然后 Ctor 为参数传给 createComponent。

createComponent 中判断它不是一个对象，所以不会调用 Vue.extend，它也没有 cid ，所以走到了异步组件的逻辑：

```js
 // async component
  // 异步组件逻辑
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    // resolveAsyncComponent 第一次执行会返回 undefined，因为工厂函数 asyncFactory 中的操作是异步的
    // 工厂函数调用后会resolve传回组件对象，然后会调用 forceRender 去调用实例的 $forceUpdate 强制重新渲染当前实例，然后就又会走到 _render ==> createElement ==> createComponent, 然后第二次走到这里的 resolveAsyncComponent 方法，这时候第二次就已经有 factory.resolved 了，直接返回，作为这个异步组件的构造器去生成对应的 vnode，然后当 vnode patch 的时候生成实例，然后生成 dom
    if (Ctor === undefined) {
      // 第一次返回 undefined 就调用 createAsyncPlaceholder 生成一个占位符 vnode 渲染为一个注释节点，将工厂函数和元数据保存下来
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }
```

然后看看 resolveAsyncComponent 中的逻辑:

```js
export function resolveAsyncComponent (
  factory: Function,
  baseCtor: Class<Component>
): Class<Component> | void {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) { // forceRender 后第二次走到这里已经有 factory.resolved 了，直接返回
    return factory.resolved
  }

  const owner = currentRenderingInstance
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner)
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    const owners = factory.owners = [owner]
    let sync = true
    let timerLoading = null
    let timerTimeout = null

    ;(owner: any).$on('hook:destroyed', () => remove(owners, owner))

    const forceRender = (renderCompleted: boolean) => {
      for (let i = 0, l = owners.length; i < l; i++) {
        //遍历 owners ，调用实例的 $forceUpdate 强制重新渲染当前实例，然后就又会走到 _render ==> createElement ==> createComponent, 然后走到 resolveAsyncComponent 方法，这时候第二次就已经有 factory.resolved 了，直接返回，作为这个异步组件的构造器去生成对应的 vnode，然后当 vnode patch 的时候生成实例，然后生成 dom
        (owners[i]: any).$forceUpdate()
      }

      if (renderCompleted) {
        owners.length = 0
        if (timerLoading !== null) {
          clearTimeout(timerLoading)
          timerLoading = null
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout)
          timerTimeout = null
        }
      }
    }

    const resolve = once((res: Object | Class<Component>) => {
      // 当工厂函数被调用后，过了一段时间（因为是异步的）resolve会被触发

      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // res 就是工厂函数里调用 resolve 传入的组件对象，利用 ensureCtor 处理一下，拿到组件的构造函数，存到 factory.resolved 上
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) { // 这里开关已经变成 false 了，因为下面的同步代码已经改变这个变量了
        // 调用 forceRender
        forceRender(true)
      } else {
        owners.length = 0
      }
    })

    const reject = once(reason => {
      process.env.NODE_ENV !== 'production' && warn(
        `Failed to resolve async component: ${String(factory)}` +
        (reason ? `\nReason: ${reason}` : '')
      )
      if (isDef(factory.errorComp)) {
        factory.error = true
        forceRender(true)
      }
    })

    // resolve 和 reject 都用 once 处理过，once 使用闭包保证这个被处理的函数只能被调用一次
    // 工厂函数中的 resolve 和 reject 只能被调用一次
    const res = factory(resolve, reject)
    // 调用 factory ，也就是用 Vue.component 注册异步组件时传入的 工厂函数

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject)

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          if (res.delay === 0) {
            factory.loading = true
          } else {
            timerLoading = setTimeout(() => {
              timerLoading = null
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender(false)
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(() => {
            timerTimeout = null
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? `timeout (${res.timeout}ms)`
                  : null
              )
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // return in case resolved synchronously
    // 第一次同步代码返回了 undefined
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```

resolveAsyncComponent 要执行两次，第一次会在其中调用 factory 传入定义好的 resolve 和 reject，因为 factory 是异步执行的，所以第一次 resolveAsyncComponent 返回 undefined。当 factory 执行结束后会触发 resolve 将组件对象传入，然后 resolve 会将组件对象通过 Vue.extend 变成构造器缓存在 factory 上，接着触发当前组件的 $forceUpdate 去强制渲染 watcher 重新渲染一次，然后就回第二次走到 resolveAsyncComponent，这时候就直接拿到第一次缓存的组件构造器，然后继续走后面的流程，创建 vnode，_update, patch, 实例化组件 vm，$mount，_render, patch。

### promise

异步组件使用返回一个 promise 的函数的方式，前期执行都和工厂模式是一样的，只是在 resolveAsyncComponent 调用 factory 后的返回值不太一样，它会返回一个 promise，然后通过处理这个返回值，调用它的 then 方法，传入定义好的 resolve 和 reject，当 promise 执行结束会触发 resolve ，后续流程就和工厂函数模式一样了。

```js
const res = factory(resolve, reject)
    // 调用 factory ，也就是用 Vue.component 注册异步组件时传入的 工厂函数

    // 如果使用的是返回一个 promise 的形式，就回来处理 res 返回值
    if (isObject(res)) {
      if (isPromise(res)) {
        // 如果 res 是个 promise，那么调用它的 then，传入 resolve 和 reject 处理，之后 resolve 逻辑和工厂函数模式一样
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      }
```

### 高级异步组件

