# 组件化

Vue.js 另⼀个核⼼思想是组件化。所谓组件化，就是把⻚⾯拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图⽚等资源放在⼀起开发和维护。组件是资源独⽴的，组件在系统内部可复⽤，组件和组件之间可以嵌套。

我们在⽤ Vue.js 开发实际项⽬的时候，就是像搭积⽊⼀样，编写⼀堆组件拼装⽣成⻚⾯。在 Vue.js 的官⽹中，也是花了⼤篇幅来介绍什么是组件，如何编写组件以及组件拥有的属性和特性。

那么在这⼀章节，我们将从源码的⾓度来分析 Vue 的组件内部是如何⼯作的，只有了解了内部的⼯作原理，才能让我们使⽤它的时候更加得⼼应⼿。

接下来我们会⽤ Vue-cli 初始化的代码为例，来分析⼀下 Vue 组件初始化的⼀个过程。

```js
import Vue from 'vue'
import App from './App.vue'

var app = new Vue({
  el: '#app',
  // 这⾥的 h 是 createElement ⽅法
  render: h => h(App)
})
```

这段代码相信很多同学都很熟悉，它和我们上⼀章相同的点也是通过 render 函数去渲染的，不同的这次通过 createElement 传的参数是⼀个组件⽽不是⼀个原⽣的标签，那么接下来我们就开始分析这⼀过程。

## createComponent

上⼀章我们在分析 createElement 的实现的时候，它最终会调⽤ _createElement ⽅法，其中有⼀段逻辑是对参数 tag 的判断，如果是⼀个普通的 html 标签，像上⼀章的例⼦那样是⼀个普通的 div，则会实例化⼀个普通 VNode 节点，否则通过 createComponent ⽅法创建⼀个组件 VNode。

```js
if (typeof tag === 'string') { // 如果 tag 是普通的 html 标签, 就新建一个 vnode
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {// 如果是 component
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else { // 如果不认识的标签名
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {// 否则创建 component
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
```

在我们这⼀章传⼊的是⼀个 App 对象，它本质上是⼀个 Component 类型，那么它会⾛到上述代码的 else 逻辑，直接通过 createComponent ⽅法来创建 vnode 。所以接下来我们来看⼀下 createComponent ⽅法的实现，它定义在 `src/core/vdom/create-component.js` ⽂件中：

```js
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void { // 此方法用于创建 component 的 vnode
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base
  // baseCtor 就是 Vue 构造函数
  // 在 src/core/global-api/index 中定义了 Vue.options._base = Vue
  // 在 Vue.prototype._init 中会把 Vue.options 合并到 vm.$options 中


  // plain options object: turn it into a constructor
  if (isObject(Ctor)) { // 如果 Ctor 是个对象，构造⼦类构造函数。Vue.extend 定义在 src/core/global-api/extend 中
    Ctor = baseCtor.extend(Ctor)
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') { // 如果子构造器生成失败，报错
    if (process.env.NODE_ENV !== 'production') {
      warn(`Invalid Component definition: ${String(Ctor)}`, context)
    }
    return
  }

  // async component
  // 异步组件逻辑
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {

      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // extract props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  const listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data) // 安装组件钩⼦函数

  // return a placeholder vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  ) // 实例化 vnode

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  if (__WEEX__ && isRecyclableComponent(vnode)) {
    return renderRecyclableComponentTemplate(vnode)
  }

  return vnode
}
```

可以看到， createComponent 的逻辑也会有⼀些复杂，但是分析源码⽐较推荐的是只分析核⼼流程，分⽀流程可以之后针对性的看，所以这⾥针对组件渲染这个 case 主要就 3 个关键步骤：构造⼦类构造函数，安装组件钩⼦函数，实例化 vnode 。

### 构造⼦类构造函数

```js
const baseCtor = context.$options._base
// plain options object: turn it into a constructor
if (isObject(Ctor)) {
  Ctor = baseCtor.extend(Ctor)
}
```

我们在编写⼀个组件的时候，通常都是创建⼀个普通对象，还是以我们的 App.vue 为例，代码如下：

```js
import HelloWorld from './components/HelloWorld'
export default {
  name: 'app',
  components: {
    HelloWorld
  }
}
```

这⾥ export 的是⼀个对象，所以 createComponent ⾥的代码逻辑会执⾏到 baseCtor.extend(Ctor) ，在这⾥ baseCtor 实际上就是 Vue，这个的定义是在最开始初始化 Vue 的阶段，在 `src/core/global-api/index.js` 中的 initGlobalAPI 函数有这么⼀段逻辑：

```js
// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue
```

细⼼的同学会发现，这⾥定义的是 Vue.option ，⽽我们的 createComponent 取的是 context.$options ，实际上在 `src/core/instance/init.js` ⾥ Vue 原型上的 _init 函数中有这么⼀段逻辑：

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {},
  vm
)
```

这样就把 Vue 上的⼀些 option 扩展到了 vm.$option 上，所以我们也就能通过 vm.$options._base 拿到 Vue 这个构造函数了。 mergeOptions 的实现我们会在后续章节中具体分析，现在只需要理解它的功能是把 Vue 构造函数的 options 和⽤户传⼊的 options 做⼀层合并，到 vm.$options 上。

在了解了 baseCtor 指向了 Vue 之后，我们来看⼀下 Vue.extend 函数的定义，在 `src/core/global-api/extend.js` 中。

```js
/**
   * Class inheritance
   */
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    const Super = this // 就是 Vue
    const SuperId = Super.cid
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    // 将生成好的子类构造器缓存优化，下次传入同样的参数就不用再次生成了

    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      validateComponentName(name) // 判断组件 name 属性是否合法，不合法就会报错
    }

    const Sub = function VueComponent (options) { // 创建了一个子构造函数，里面也是调用了 Vue.prototype._init
      this._init(options)
    }
    Sub.prototype = Object.create(Super.prototype) // Sub 构造函数继承自 Vue
    Sub.prototype.constructor = Sub
    Sub.cid = cid++
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    ) // 自身的 options 和 Vue.optinos 做了合并
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    cachedCtors[SuperId] = Sub // 将 Sub 构造函数缓存
    return Sub
  }
```

Vue.extend 的作⽤就是构造⼀个 Vue 的⼦类，它使⽤⼀种⾮常经典的原型继承的⽅式把⼀个纯对象转换为⼀个继承于 Vue 的构造器 Sub 并返回，然后对 Sub 这个对象本⾝扩展了⼀些属性，如扩展 options 、添加全局 API 等；并且对配置中的 props 和 computed 做了初始化⼯作；最后对于这个 Sub 构造函数做了缓存，避免多次执⾏ Vue.extend 的时候对同⼀个⼦组件重复构造。

这样当我们去实例化 Sub 的时候，就会执⾏ this._init 逻辑再次⾛到了 Vue 实例的初始化逻辑，实例化⼦组件的逻辑在之后的章节会介绍。

```js
const Sub = function VueComponent (options) {
  this._init(options)
}
```

### 安装组件钩⼦函数

```js
// install component management hooks onto the placeholder node
installComponentHooks(data)
```

我们之前提到 Vue.js 使⽤的 Virtual DOM 参考的是开源库 snabbdom，它的⼀个特点是在 VNode 的 patch 流程中对外暴露了各种时机的钩⼦函数，⽅便我们做⼀些额外的事情，Vue.js 也是充分利⽤这⼀点，在初始化⼀个 Component 类型的 VNode 的过程中实现了⼏个钩⼦函数：

```js
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = { // 组件钩子 init prepatch insert destroy
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}

const hooksToMerge = Object.keys(componentVNodeHooks)

function installComponentHooks (data: VNodeData) { // 初始化组件钩子
  const hooks = data.hook || (data.hook = {})
  for (let i = 0; i < hooksToMerge.length; i++) { // 遍历四个钩子 init prepatch insert destroy
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      // 将 VnodeData 的 hook 也就是用户自定义的 hook 和 vnode 默认的 hook 合并，钩子触发后会依次执行
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}


```

整个 installComponentHooks 的过程就是把 componentVNodeHooks 的钩⼦函数合并到 data.hook 中，在 VNode 执⾏ patch 的过程中执⾏相关的钩⼦函数，具体的执⾏我们稍后在介绍 patch 过程中会详细介绍。这⾥要注意的是合并策略，在合并过程中，如果某个时机的钩⼦已经存在 data.hook 中，那么通过执⾏ mergeHook 函数做合并，这个逻辑很简单，就是在最终执⾏的时候，依次执⾏这两个钩⼦函数即可。

### 实例化 VNode

```js
 // return a placeholder vnode
  const name = Ctor.options.name || tag
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  ) // 实例化 vnode
```

最后⼀步⾮常简单，通过 new VNode 实例化⼀个 vnode 并返回。需要注意的是和普通元素节点的vnode 不同，组件的 vnode 是没有 children 的，这点很关键，在之后的 patch 过程中我们会再提。

### 总结

这⼀节我们分析了 createComponent 的实现，了解到它在渲染⼀个组件的时候的 3 个关键逻辑：构造⼦类构造函数，安装组件钩⼦函数，实例化 vnode。createComponent 后返回的是组件 vnode ，它也⼀样⾛到 vm._update ⽅法，进⽽执⾏了 patch 函数，我们在上⼀章对 patch 函数做了简单的分析，那么下⼀节我们会对它做进⼀步的分析。

## patch

```js
// main.js

import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h => h(App),
}).$mount('#app')


// App.vue
<template>
  <div id="app">
    <img alt="Vue logo" src="./assets/logo.png">
    <HelloWorld msg="Welcome to Your Vue.js App"/>
  </div>
</template>

<script>
import HelloWorld from './components/HelloWorld.vue'

export default {
  name: 'App',
  components: {
    HelloWorld
  }
}
</script>

// HelloWorld.vue

<template>
  <div class="hello">
  ......
  </div>
</template>

<script>
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  }
}
</script>


```

* 首先是下面 main.js 中的根组件初始化

```js
new Vue({
  render: h => h(App),
}).$mount('#app')
```

走完 Vue.prototype._init 后，会走到 Vue.prototype.$mount 然后调用 mountComponent，在 mountComponent 中会给 vm.$el 赋值为 div#app。

* 因为我们已经在 option 中提供了 render 方法，所以会走到 mountComponent 中这一句：

```js
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```

然后 updateComponent 会传递给 Watcher 为参数，创建新的渲染 Watcher 实例。

* 然后渲染 Watcher 会触发刚才的 updateComponent 中的 vm._render()，也就是 Vue.prototype._render。

* 接着 Vue.prototype._render 里会走到这一句

```js
  vnode = render.call(vm._renderProxy, vm.$createElement);
```
render 就是在根组件直接传入的 render: h => h(App)，而这个 h 参数就是 vm.$createElement。也就是：

```js
vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
```

所以最后调用 createElement 的时候只有 vm 和 a 参数，a 参数就是 App.vue 组件。App.vue 组件已经被 webpack 的 loader 处理成了带有 render 参数的一个对象。

* 下来调用 _createElement。

```js
_createElement(context, tag, data, children, normalizationType)
```

这时候 context 参数是根组件 vm，tag 是 App.vue 组件。所以这时候 tag 参数不是字符串，会调用 createComponent去继续创建 App.vue 组件

```js
vnode = createComponent(tag, data, context, children);
```

这时候一样的，createComponent 接收的 tag 参数是 App.vue 组件对象，context 参数是根组件 vm。

* createComponent 中走到下面这段逻辑

```js
  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }
```

baseCtor 其实就是 Vue 构造函数，而这里的 Ctor 就是接收的参数 tag，就是 App.vue 组件对象，它是一个对象，所以就调用 Vue.extend 创建一个继承自 Vue 的子类构造函数 Sub 然后赋值给 Ctor。

刚进入 createComponnet 的时候接收的 data 参数是个空对象，走到下面这个逻辑：

```js
 installComponentHooks(data);
```

installComponentHooks 会将 4 个 组件的钩子函数加入到 data.hook 中。然后 new 一个组件 vnode：

```js
const vnode = new VNode(
  `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
  data, undefined, undefined, undefined, context,
  { Ctor, propsData, listeners, tag, children },
  asyncFactory
)
// 生成 vnode。component 的 vnode 和普通 vnode 不一样，第三个参数 children 是 undefined。也就是说 component 对应的 vnode 的 children 是空。但是它有 componentOptions 是一个对象，里面有 children
```

后面就会知道这个组件 vnode 是一个占位符 vnode。

* 这时候这个 App.vue 对应的组件 vnode 返回了，Vue.prototype._render 也执行完返回了，

```js
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```

返回到这里，作为 vm._render() 的结果，然后作为参数传给 vm._update() 执行。

* Vue.prototype._update 执行的时候要注意这里

```js
var vm = this;
var prevEl = vm.$el;
var prevVnode = vm._vnode;
var restoreActiveInstance = setActiveInstance(vm);
vm._vnode = vnode;
```

这时候的 vm 还是 根组件，所以 prevVnode 为空，然后调用 setActiveInstance 将全局变量 activeInstance 设置为当前根组件 vm。

然后把 vm._vnode 赋值为 之前 vm._render() 生成的 占位符 vnode，对应 App.vue 组件。然后执行 __patch__

```js
if (!prevVnode) {
  // initial render
  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
}
```

* patch 方法

```js
patch (oldVnode, vnode, hydrating, removeOnly) {
```

oldVnode 是 div#app 元素，vnode 是 App.vue 组件对应的 占位符 vnode。

```js
oldVnode = emptyNodeAt(oldVnode);
```

根据 div#app 元素生成空的 vnode 节点。

```js
var oldElm = oldVnode.elm; // div#app
var parentElm = nodeOps.parentNode(oldElm); // div#app 的父级 body 元素
```

接下来调用 createElm 方法

```js
createElm(
  vnode,
  insertedVnodeQueue,
  // extremely rare edge case: do not insert if old element is in a
  // leaving transition. Only happens when combining transition +
  // keep-alive + HOCs. (#4590)
  oldElm._leaveCb ? null : parentElm,
  nodeOps.nextSibling(oldElm)
);
```

* createElm 

```js
function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

```

vnode 是 App.vue 占位符 vnode，parentElm 是 body 元素，refElm 是个文本节点换行符。这时候走到 createComponent 这句

```js
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
  var i = vnode.data;
  if (isDef(i)) {
    var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
    if (isDef(i = i.hook) && isDef(i = i.init)) {
      i(vnode, false /* hydrating */);
    }
    // after calling the init hook, if the vnode is a child component
    // it should've created a child instance and mounted it. the child
    // component also has set the placeholder vnode's elm.
    // in that case we can just return the element and be done.
    if (isDef(vnode.componentInstance)) {
      initComponent(vnode, insertedVnodeQueue);
      insert(parentElm, vnode.elm, refElm);
      if (isTrue(isReactivated)) {
        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
      }
      return true
    }
  }
}
```

会去执行 vnode.data.hook.init()，也就是当时 installComponentHooks 的 4 个组件钩子函数中的 init。

```js
init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },
```

然后会调用 createComponentInstanceForVnode, vnode 是 App.vue 占位符 vnode，activeInstance 是全局变量当前激活的实例，根组件 vm 实例。

```js
function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode, // App.vue 占位符 vnode
    parent: parent // 根组件 vm 实例
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options) // 调用当时为 App.vue 组件创建的 Sub 子类构造函数
}
```

Sub 子类构造函数又走到了 Vue.prototype._init 里，这时候初始化的是 App.vue 这个组件了。也就是先初始化根组件，然后初始化根组件的子组件 App.vue。

```js
if (options && options._isComponent) {
  // optimize internal component instantiation
  // since dynamic options merging is pretty slow, and none of the
  // internal component options needs special treatment.
  initInternalComponent(vm, options)
}
```

Vue.prototype._init 的时候 options._isComponent 为 true，走到了 initInternalComponent 里。这时候 vm 是 Sub 子类的实例。options 是刚才 createComponentInstanceForVnode 中传入的 

```js
var options = {
  _isComponent: true,
  _parentVnode: vnode, // App.vue 占位符 vnode
  parent: parent // 根组件 vm 实例
};
```

下面是 initInternalComponent，用于给 Sub 的实例的 options 添加一些属性

```js
function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode; // App.vue 占位符 vnode
  opts.parent = options.parent; // 根组件 vm 实例
  opts._parentVnode = parentVnode; // App.vue 占位符 vnode

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}
```

_init 中的 initLifecycle 调用后，会将子组件的 $parent 指向子组件的 options.parent，同时父组件的 $children 也 push 了子组件， 这样就建立了父子级的关系。

```js
export function initLifecycle (vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent // 父组件
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm) // vm 是子组件，push 到父组件的$children中
  }

  vm.$parent = parent // 子组件$parent指向父组件
```

继续往下走，

```js
if (vm.$options.el) {
  vm.$mount(vm.$options.el)
}
```

这时候 不会走 $mount，因为这时候是 App.vue 组件，用 Sub 子类生成的，还没有 el 参数

_init 结束。Sub 构造结束，回到 createComponentInstanceForVnode。

```js
return new vnode.componentOptions.Ctor(options)
```

然后回到 init 钩子函数：

```js
init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating); // 在这里 $mount
    }
  },
```

可以看到 createComponentInstanceForVnode 生成的 Sub 子类的实例就是 App.vue 对应的 Vue 实例，赋值给 App.vue 占位符 vnode 的 componentInstance 属性，然后调用其 $mount。

* mountComponent 中又走到了下面的逻辑：

```js
updateComponent = function () {
  vm._update(vm._render(), hydrating);
};
```

这时候的 vm 是 App.vue 实例了。然后 updateComponent 传递给新的渲染 Watcher，里面会触发 Vue.prototype._render

* Vue.prototype._render 会把 vm.$vnode 赋值为占位符 vnode 

```js
vm.$vnode = _parentVnode;
```

然后 _render 的后续流程是根据 App.vue 的占位符 vnode 生成渲染 vnode。

此刻 App.vue 实例的 render 函数是从 template 编译而来，就使用 vm._c

```js
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { attrs: { id: "app" } },
    [
      _c("img", {
        attrs: { alt: "Vue logo", src: require("./assets/logo.png") }
      }),
      _c("HelloWorld", { attrs: { msg: "Welcome to Your Vue.js App" } })
    ],
    1
  )
}
```
我们发现调用了三次 vm._c ，第一次生成 div#app，然后是 img，然后是 HelloWorld 组件。因为是组件，执行 _createElement 的时候会走下面

```js
vnode = createComponent(Ctor, data, context, children, tag);
```

这时候就回去调用 createComponent 创建 HelloWorld 组件的占位符 vnode，之后的流程就和创建 App.vue 的时候类似了。



* 根组件初始化
* Vue.prototype._init
* mountComponent
* updateComponent 传给 new Watcher()
* updateComponent 触发，执行 vm._render()
* Vue.prototype._render
* createElement
* _createElement
* createComponent，开始去创建 App.vue 的占位符 vnode
* 调用 Vue.extend 创建App组件的构造函数 Sub
* installComponentHooks 初始化组件 hook
* 生成 App.vue 的占位符 vnode，Vue.prototype._render 到这里执行结束，回到 updateComponent 中的逻辑
* vm._update()，vm 是根组件实例
* __patch__，patch
* createElm
* patch 中的 createComponent 方法
* 执行 vnode.data.hook.init()
* createComponentInstanceForVnode 中调用 Sub 子类构造函数创建 App.vue 组件的 vm 实例
* Vue.prototype._init 这时候是初始化 App.vue 组件
* Sub 构造 App 组件实例结束，回到 createComponentInstanceForVnode，然后回到 vnode.data.hook.init()
* init 最后调用 child.$mount，开始 $mount App 组件
* mountComponent
* updateComponent 传给 new Watcher()
* updateComponent 触发，执行 vm._render()
* Vue.prototype._render 中调用通过 template 模板编译而来的 render 函数，其中调用多次 vm._c
* vm._c 会调用 createElement _createElement
* 如果 vm._c 处理的是普通节点，那么就会生成 vnode 然后等待 _update 中的 patch 流程转换 vnode 为真实 dom
* 如果 vm._c 处理的是组件，那么又会走到 createComponent 去生成占位符 vnode

## 配置合并

有两次配置合并：外部调用场景，new Vue 的时候；组件场景的配置合并，组件初始化的时候。

首先看看 mixin 是做什么的，在 `src/core/global-api/mixin.js`

```js
export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin) // mergeOptions 把 mixin 传入的参数合并到 Vue.options
    return this
  }
}

```

mixin 方法其实就是调用 mergeOptions 方法把传入的参数合并到 Vue.options 上。

接着我们去看两次配置合并的代码，在 `src/core/instance/init.js` 的 Vue.prototype._init 中：

```js
if (options && options._isComponent) {
  // 组件vnode patch 的时候会调用组件内部hook的init，然后会调用到子类构造函数Sub，Sub会调用 this._init走到这里，这时候的vm是Sub子类的实例
  // optimize internal component instantiation
  // since dynamic options merging is pretty slow, and none of the
  // internal component options needs special treatment.
  initInternalComponent(vm, options)
} else {
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {}, // 用户 new Vue 的时候传入的 options
    vm
  )
  // 第一次 new Vue 的时候会调用 mergeOptions 合并配置
}
```

new Vue 的时候使用 mergeOptions 将 Vue.options 和用户传入的 options 合并作为新实例的 $options。而组件的 options 合并调用 initInternalComponent 处理。

mergeOptions 在 `src/core/util/options.js` 中

```js
export function mergeOptions (
  parent: Object,
  child: Object,
  vm?: Component
): Object {
  if (process.env.NODE_ENV !== 'production') {
    checkComponents(child)
  }

  if (typeof child === 'function') {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    // 循环 child 的 extends 和 mixins 属性，将其中的 option 调用 mergeOptions 合并入 parent
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options = {}
  let key
  for (key in parent) { // 遍历 parent ，调用 mergeField 将 parent 中 option 合并到 options 变量中
    mergeField(key)
  }
  for (key in child) { // 遍历 child ，如果 parent 没有这个 key，调用 mergeField 将其合并到 options 变量中
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField (key) {
    const strat = strats[key] || defaultStrat
    // 通过不同的 key 拿到不同的 strats 函数
    // strats 是对各种不同的 option 定义了对应的合并策略
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

mergeOptions 其实就是根据 options 的不同 key 值执行不同的合并策略将其合并到一个空对象上，然后将这个对象返回。

以合并生命周期的策略为例子：

```js
function mergeHook (
  parentVal: ?Array<Function>,
  childVal: ?Function | ?Array<Function>
): ?Array<Function> { // 生命周期的合并，最后会返回一个数组
  const res = childVal
    ? parentVal
      ? parentVal.concat(childVal) // 子和父都定义了就把子和父连接成数组
      : Array.isArray(childVal) // 子定义了就看父，如果父没有定义，就判断子是不是数组，如果是数组直接返回，如果不是数组就变成一个数组
        ? childVal
        : [childVal]
    : parentVal // 子没有定义，直接取父
  return res
    ? dedupeHooks(res)
    : res
}
```

可以看出生命周期的合并将多个同名的生命周期合并成了函数组成的数组返回，当生命周期执行时，就是将这个数组里的函数依次执行。


以下面这个简单例子来分析：


```js
import Vue from 'vue'

let childComp = {
  template: '<div>{{msg}}</div>',
  created() {
    console.log('child created')
  },
  mounted() {
    console.log('child mounted')
  },
  data() {
    return {
      msg: 'Hello Vue'
    }
  }
}

Vue.mixin({
  created() {
    console.log('parent created')
  }
})

let app = new Vue({
  el: '#app',
  render: h => h(childComp)
})
```

* 先执行 Vue.mixin `src/core/global-api/mixin.js`

```js
export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin) // mergeOptions 把 mixin 传入的参数合并到 Vue.options
    return this
  }
}

```

然后进入 mergeOptions，将 mixin 传入的 created 合并到 Vue.options，这时候 Vue.options.created 就是一个 `[f]` 函数数组

* 然后 new Vue 走到 Vue.prototype._init，又走到了

```js
vm.$options = mergeOptions(
  resolveConstructorOptions(vm.constructor),
  options || {}, // 用户 new Vue 的时候传入的 options
  vm
)
```

会将 Vue.options 和 new Vue 传入的 options 合并作为 vm.$options，这样 vm.$options 也和 Vue.options 一样拥有了 created 生命周期函数的函数数组

* 接着初始化子组件的时候调用了 Vue.extend 去生成 Sub 子类构造函数，其中调用了 mergeOptions 将子组件的 options 和 Vue.options 合并作为 Sub.options

```js
 Sub.options = mergeOptions(
    Super.options,
    extendOptions
  );
```

子组件的 options 也有 created 生命周期钩子，经过 mergeOptions 合并后，created 的值为 [f, f]，父组件的 created 在前，子组件的 created 在后

然后接着会调用 Vue.prototype._init 初始化子组件 Sub 实例，进入 initInternalComponent 方法，它会为 Sub 子组件实例生成 vm.$options 属性，继承自 Sub.options。

## 生命周期

callHook 用来调用生命周期钩子函数，定义在 `src/core/instance/lifecycle.js`

```js
export function callHook (vm: Component, hook: string) { // 调用生命周期钩子函数
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const handlers = vm.$options[hook] // vm.$options.hook 是合并后的 hook 组成的数组
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) { // 遍历钩子函数组成的数组，然后调用
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) { // 如果 vm 实例上 $on 监听了 hook 生命周期钩子事件，就 $emit 发送该事件触发回调函数
    vm.$emit('hook:' + hook)
  }
  popTarget()
}
```

* beforeCreate 和 created

去看 Vue.prototype._init 中触发的两个生命周期钩子

```js
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm) // 初始化 data 对象，并添加响应式
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

可以看出 beforeCreate 和 created 的区别，beforeCreate 的时候是拿不到 data props methods 数据的，如果想要通过 this 拿到实例上的数据，需要在 created 里操作，因为初始化 data props methods 是在 initState(vm) 这一步做的。


* beforeMount 和 mounted

mount 挂载的流程首先会执行 `src/core/instance/lifecycle.js` 中的 mountComponent，mountComponent 中调用 callHook(vm, 'beforeMount')。而嵌套多个组件的时候，走到子组件的 mount 时，又会执行 mountComponent，所以父子组件的 beforeMount 的顺序是 先父后子。

如果没有嵌套的子组件，那么等到 _render _update 流程走完之后就会 callHook(vm, 'mounted')。

如果有多个嵌套子组件的话，就会是如下流程：

* 父组件 mountComponent
* 父组件 callHook(vm, 'beforeMount')
* _render
* vm.$createElement
* _createElement
* createComponent
* installComponentHooks(data) 为 data 添加组件钩子
* createComponent 生成占位符 vnode 返回
* 父组件 _update
* 父组件 patch
* patch createElm
* patch createComponent
* 调用 installComponentHooks 添加的 init 钩子
* init 钩子会调用 Sub 子组件构造函数创建子组件实例，然后调用子组件 $mount
* 当子组件的 mount 流程走完后，会触发操作将子组件 vnode 插入 insertedVnodeQueue，子组件 vnode 会先插入insertedVnodeQueue
* 等到子组件 mount 走完了，patch 流程的最后会触发 invokeInsertHook ，遍历 insertedVnodeQueue，触发所有子组件的 insert 钩子，其中会 callHook(componentInstance, 'mounted')，触发 mounted 生命周期

所以根据上面的分析，mounted 的顺序是 先子后父

* beforeUpdate 和 updated

mount 流程中的 mountComponent，其中会 new 一个 Watcher，传入了一个对象参数：

```js
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
```

这个参数中的 before 方法会在 `src/core/observer/scheduler.js` 中的 flushSchedulerQueue 方法中被调用。nextTick 的时候会执行 flushSchedulerQueue。

Watcher 更新完之后会执行 callHook(vm, 'updated')。

* beforeDestroy 和 destroyed

销毁流程会触发 Vue.prototype.$destroy，beforeDestroy 先父后子，beforeDestroy 触发后会调用 vm.__patch__(vm._vnode, null)，第二个参数传 null 会触发销毁操作，其中会遍历子组件，然后调用子组件的 $destroy，所以 destroyed 是先子后父。

## 组件注册

组件注册包括全局注册和局部注册两种方式。

* 全局注册调用 `Vue.component`，定义在 `src/core/global-api/assets` 中

```js
  ASSET_TYPES.forEach(type => {
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') { // 开发环境下对组件名做校验
          validateComponentName(id)
        }
        if (type === 'component' && isPlainObject(definition)) { // 如果调用的是 Vue.component 组件注册，并且 definition 是对象
          definition.name = definition.name || id // 如果定义没有 name ，就取 id
          definition = this.options._base.extend(definition) // 调用 Vue.extend 生成子组件构造函数
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        this.options[type + 's'][id] = definition // 在 Vue.options 上加入对应的定义
        return definition
      }
    }
  })
```

可以看到调用 Vue.extend 生成子组件的构造函数后，会将其挂到 `Vue.options.components[id]` 上，那么是什么时候使用呢？

是在 _render 触发后调用 createElement 的时候使用，createElement 最终会调用 _createElement 生成 Vnode，_createElement 中有这样一句：

```js
 else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {// 如果是 component
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    }
```

这里会调用 resolveAsset 去在 `Vue.options.components` 上找这个标签名对应的组件。注意这里的 context.$options 是经过 mergeOptions 合并而来，所以包含了 Vue.options。

```js
export function resolveAsset (
  options: Object,
  type: string,
  id: string,
  warnMissing?: boolean
): any {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  const assets = options[type]
  // check local registration variations first
  if (hasOwn(assets, id)) return assets[id] // 如果options[type][id] 存在直接返回
  const camelizedId = camelize(id) // camelize('aa-bb-cc') "aaBbCc" 把连字符写法转换成驼峰写法
  if (hasOwn(assets, camelizedId)) return assets[camelizedId] // 用驼峰写法继续找options[type][id] 是否存在
  const PascalCaseId = capitalize(camelizedId) // 首字母大写的驼峰写法
  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId] // 首字母大写的驼峰写法是否存在
  // fallback to prototype chain
  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    )
  }
  return res
}

```

找到了对应的子构造函数就传递给 createComponent 作为参数去创建组件 vnode，然后挂在 vnode.componentOptions 上面，等待后续占位符 vnode 走到 patch 流程后调用组件钩子 init 的时候会被触发，创建子组件的实例。


* 局部注册组件其实走的是 Vue.extend 生成了 Sub 子构造函数，并且 Sub.options  是 mergeOptions 合并了 Super.options 和 extendOptions。然后走到 _init 的时候会走到 initInternalComponent，有这样一句：

```js
const opts = vm.$options = Object.create(vm.constructor.options)
```

子组件实例的 $options 是继承自 Sub.options，因此，resolveAsset 的时候通过 vm.$options.components 就能够拿到子组件的构造器。

## 异步组件

### 工厂函数

异步组件还是调用 Vue.component 注册的，他和普通组件的区别是，第二个参数不是一个对象，而是一个函数：

```js
Vue.component('async-webpack-example', function (resolve) {
  // 这个特殊的 `require` 语法将会告诉 webpack
  // 自动将你的构建代码切割成多个包，这些包
  // 会通过 Ajax 请求加载
  require(['./my-async-component'], resolve)
})
```

所以还是会走到 Vue.component 的逻辑，Vue.component 中对第二个参数 definition 是函数的情况没有做处理，直接将 definition 挂到 `Vue.options.components[id]` 上。

后面当创建 vnode 的时候，会走到 `src/core/vdom/create-element.js` 中的 _createElement，会调用 resolveAsset 从 Vue.options.components 上找到对应的这个函数作为 Ctor，然后 Ctor 为参数传给 createComponent。

createComponent 中判断它不是一个对象，所以不会调用 Vue.extend，它也没有 cid ，所以走到了异步组件的逻辑：

```js
 // async component
  // 异步组件逻辑
  let asyncFactory
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    // resolveAsyncComponent 第一次执行会返回 undefined，因为工厂函数 asyncFactory 中的操作是异步的
    // 工厂函数调用后会resolve传回组件对象，然后会调用 forceRender 去调用实例的 $forceUpdate 强制重新渲染当前实例，然后就又会走到 _render ==> createElement ==> createComponent, 然后第二次走到这里的 resolveAsyncComponent 方法，这时候第二次就已经有 factory.resolved 了，直接返回，作为这个异步组件的构造器去生成对应的 vnode，然后当 vnode patch 的时候生成实例，然后生成 dom
    if (Ctor === undefined) {
      // 第一次返回 undefined 就调用 createAsyncPlaceholder 生成一个占位符 vnode 渲染为一个注释节点，将工厂函数和元数据保存下来
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }
```

然后看看 resolveAsyncComponent 中的逻辑:

```js
export function resolveAsyncComponent (
  factory: Function,
  baseCtor: Class<Component>
): Class<Component> | void {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) { // forceRender 后第二次走到这里已经有 factory.resolved 了，直接返回
    return factory.resolved
  }

  const owner = currentRenderingInstance
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner)
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    const owners = factory.owners = [owner]
    let sync = true
    let timerLoading = null
    let timerTimeout = null

    ;(owner: any).$on('hook:destroyed', () => remove(owners, owner))

    const forceRender = (renderCompleted: boolean) => {
      for (let i = 0, l = owners.length; i < l; i++) {
        //遍历 owners ，调用实例的 $forceUpdate 强制重新渲染当前实例，然后就又会走到 _render ==> createElement ==> createComponent, 然后走到 resolveAsyncComponent 方法，这时候第二次就已经有 factory.resolved 了，直接返回，作为这个异步组件的构造器去生成对应的 vnode，然后当 vnode patch 的时候生成实例，然后生成 dom
        (owners[i]: any).$forceUpdate()
      }

      if (renderCompleted) {
        owners.length = 0
        if (timerLoading !== null) {
          clearTimeout(timerLoading)
          timerLoading = null
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout)
          timerTimeout = null
        }
      }
    }

    const resolve = once((res: Object | Class<Component>) => {
      // 当工厂函数被调用后，过了一段时间（因为是异步的）resolve会被触发

      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // res 就是工厂函数里调用 resolve 传入的组件对象，利用 ensureCtor 处理一下，拿到组件的构造函数，存到 factory.resolved 上
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) { // 这里开关已经变成 false 了，因为下面的同步代码已经改变这个变量了
        // 调用 forceRender
        forceRender(true)
      } else {
        owners.length = 0
      }
    })

    const reject = once(reason => {
      process.env.NODE_ENV !== 'production' && warn(
        `Failed to resolve async component: ${String(factory)}` +
        (reason ? `\nReason: ${reason}` : '')
      )
      if (isDef(factory.errorComp)) {
        factory.error = true
        forceRender(true)
      }
    })

    // resolve 和 reject 都用 once 处理过，once 使用闭包保证这个被处理的函数只能被调用一次
    // 工厂函数中的 resolve 和 reject 只能被调用一次
    const res = factory(resolve, reject)
    // 调用 factory ，也就是用 Vue.component 注册异步组件时传入的 工厂函数

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject)

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          if (res.delay === 0) {
            factory.loading = true
          } else {
            timerLoading = setTimeout(() => {
              timerLoading = null
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender(false)
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(() => {
            timerTimeout = null
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? `timeout (${res.timeout}ms)`
                  : null
              )
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // return in case resolved synchronously
    // 第一次同步代码返回了 undefined
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```

resolveAsyncComponent 要执行两次，第一次会在其中调用 factory 传入定义好的 resolve 和 reject，因为 factory 是异步执行的，所以第一次 resolveAsyncComponent 返回 undefined。当 factory 执行结束后会触发 resolve 将组件对象传入，然后 resolve 会将组件对象通过 Vue.extend 变成构造器缓存在 factory 上，接着触发当前组件的 $forceUpdate 去强制渲染 watcher 重新渲染一次，然后就回第二次走到 resolveAsyncComponent，这时候就直接拿到第一次缓存的组件构造器，然后继续走后面的流程，创建 vnode，_update, patch, 实例化组件 vm，$mount，_render, patch。

### promise

```js
Vue.component(
  'async-webpack-example',
  // 这个动态导入会返回一个 `Promise` 对象。
  () => import('./my-async-component')
)
```

异步组件使用返回一个 promise 的函数的方式，前期执行都和工厂模式是一样的，只是在 resolveAsyncComponent 调用 factory 后的返回值不太一样，它会返回一个 promise，然后通过处理这个返回值，调用它的 then 方法，传入定义好的 resolve 和 reject，当 promise 执行结束会触发 resolve ，后续流程就和工厂函数模式一样了。

```js
const res = factory(resolve, reject)
    // 调用 factory ，也就是用 Vue.component 注册异步组件时传入的 工厂函数

    // 如果使用的是返回一个 promise 的形式，就回来处理 res 返回值
    if (isObject(res)) {
      if (isPromise(res)) {
        // 如果 res 是个 promise，那么调用它的 then，传入 resolve 和 reject 处理，之后 resolve 逻辑和工厂函数模式一样
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      }
```

### 高级异步组件

```js
const AsyncComponent = () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})

Vue.component('AsyncComponent', AsyncComponent)
```

一样的流程，resolveAsyncComponent 中调用 factory 后，也就是 Vue.component 传入的函数，返回值 res 就是那个对象。接下来处理这个对象的逻辑不一样。

```js
export function resolveAsyncComponent (
  factory: Function,
  baseCtor: Class<Component>
): Class<Component> | void {
  if (isTrue(factory.error) && isDef(factory.errorComp)) { // 如果 factory.error 标记开启了，并且有 error 组件，那么返回 error 组件去渲染
    return factory.errorComp
  }

  if (isDef(factory.resolved)) { // forceRender 后第二次走到这里已经有 factory.resolved 了，直接返回
    return factory.resolved
  }

  const owner = currentRenderingInstance
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner)
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) { // 如果 loading 标记开启，返回 loading 组件去渲染
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    const owners = factory.owners = [owner]
    let sync = true
    let timerLoading = null
    let timerTimeout = null

    ;(owner: any).$on('hook:destroyed', () => remove(owners, owner))

    const forceRender = (renderCompleted: boolean) => {
      for (let i = 0, l = owners.length; i < l; i++) {
        //遍历 owners ，调用实例的 $forceUpdate 强制重新渲染当前实例，然后就又会走到 _render ==> createElement ==> createComponent, 然后走到 resolveAsyncComponent 方法，这时候第二次就已经有 factory.resolved 了，直接返回，作为这个异步组件的构造器去生成对应的 vnode，然后当 vnode patch 的时候生成实例，然后生成 dom
        (owners[i]: any).$forceUpdate()
      }

      if (renderCompleted) {
        owners.length = 0
        if (timerLoading !== null) {
          clearTimeout(timerLoading)
          timerLoading = null
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout)
          timerTimeout = null
        }
      }
    }

    const resolve = once((res: Object | Class<Component>) => {
      // 当工厂函数被调用后，过了一段时间（因为是异步的）resolve会被触发

      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // res 就是工厂函数里调用 resolve 传入的组件对象，利用 ensureCtor 处理一下，拿到组件的构造函数，存到 factory.resolved 上
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) { // 这里开关已经变成 false 了，因为下面的同步代码已经改变这个变量了
        // 调用 forceRender
        forceRender(true)
      } else {
        owners.length = 0
      }
    })

    const reject = once(reason => {
      process.env.NODE_ENV !== 'production' && warn(
        `Failed to resolve async component: ${String(factory)}` +
        (reason ? `\nReason: ${reason}` : '')
      )
      if (isDef(factory.errorComp)) { // 如果定义了 error 组件，factory.error 开启，然后调用 forceRender 重新渲染
        factory.error = true
        forceRender(true)
      }
    })

    // resolve 和 reject 都用 once 处理过，once 使用闭包保证这个被处理的函数只能被调用一次
    // 工厂函数中的 resolve 和 reject 只能被调用一次
    const res = factory(resolve, reject)
    // 调用 factory ，也就是用 Vue.component 注册异步组件时传入的 工厂函数

    // 如果使用的是返回一个 promise 的形式，就回来处理 res 返回值
    if (isObject(res)) {
      if (isPromise(res)) {
        // 如果 res 是个 promise，那么调用它的 then，传入 resolve 和 reject 处理，之后 resolve 逻辑和工厂函数模式一样
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isPromise(res.component)) { // 高级异步组件返回的对象中的 componnet 属性是import()引入的组件，是个 promise
        res.component.then(resolve, reject) // 调用它的then，传入 resolve 和 reject 处理，之后 resolve 逻辑和工厂函数模式一样

        if (isDef(res.error)) { // 如果传递了 error 组件，就调用 ensureCtor 将其转化成一个构造器，然后存在 factory.errorComp 上
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          // 如果传递了 loading 组件，调用 ensureCtor 将其转化成构造器，存在 factory.loadingComp 上
          if (res.delay === 0) { // 如果 loading 组件延迟显示时间为 0，就把  factory.loading 标记改成 true
            factory.loading = true
          } else { // 否则就存下一个定时器，时间为传入的 delay 参数，等到 delay 时间过去后，修改 factory.loading 标记，然后触发 forceRender
            timerLoading = setTimeout(() => {
              timerLoading = null
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender(false)
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) { // 如果提供了超时时间 timeout，存下超时时间定时器，timeout 时间过去后，如果factory.resolved 缓存的组件构造器还没有生成，调用 reject 方法
          timerTimeout = setTimeout(() => {
            timerTimeout = null
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? `timeout (${res.timeout}ms)`
                  : null
              )
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // return in case resolved synchronously
    // 第一次同步代码返回了 undefined
    // 如果loading 状态开启了，直接返回 loading 组件去渲染
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```


总结：异步组件其实就是渲染了两次，第一次渲染成一个注释节点，然后等到组件 resolve 完成后触发 $forceUpdate 重新渲染。