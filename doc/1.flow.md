# flow

flow 是一个 js 的静态检查工具。它通过两种方式来检查代码中可能出现的类型错误。

* 第一种是通过静态类型注释的方式：

```js
// @flow
function square(n: number): number {
  return n * n;
}

square("2"); // Error!
```

通过显式地注释标出 square 函数的参数 n 期望是 number 类型，以及 square 函数的返回值期望 number 类型。

* 第二种是让 flow 自己来判断是否变量有类型错误:

```js
// @flow
function square(n) {
  return n * n; // Error!
}

square("2");
```

不需要显示地标出期望的类型，只在代码文件第一行加上 `// @flow` 注释，让 flow 自行判断是否有类型错误。

## 安装

* 编译器

在项目中使用 flow 首先需要安装一个编译器，用来剥离 flow 的类型定义。可以选用 [babel](https://babeljs.io/) 或者 [flow-remove-types](https://www.npmjs.com/package/flow-remove-types)。我们这里选用 babel 作为编译器。

```js
yarn add --dev @babel/core @babel/cli @babel/preset-flow
```

运行上面命令安装 `@babel/core` `@babel/cli` `@babel/preset-flow` 这三个依赖后，在 `babel.config.js` 中添加 `presets` 设置：

```js
// babel.config.js

module.exports = {
  presets: [
    '@babel/preset-flow'
  ]
}

```

* 安装 flow

flow 最好给每个项目安装明确指定的版本而不是全局安装。

```js
//安装 flow
yarn add --dev flow-bin

//运行 flow
yarn run flow
```

## 用法

对于一个新的 flow 项目来说，一般遵循下面几点来使用 flow ：

* 使用 `flow init` 来初始化

```js
flow init
```

运行这句命令后会在项目根目录下生成 `.flowconfig` 文件。这个文件会告诉 flow 的后台进程如何去检查代码中的错误。


* 运行 flow 的后台进程

```js
flow status
```

这个命令会启动一个后台进程检查所有 flow 文件的错误，它会一直运行监测文件的变化然后检查错误。运行 `flow stop` 来停止后台进程。


* 使用 `// @flow` 决定哪些文件会被 flow 监测

在想要被 flow 检查的文件的第一行添加注释 `// @flow` 即可，这样 flow 就会自动检查这个文件。也可以用 `/* @flow */`。

* 为项目写 flow 代码

为函数写 flow 代码，例如：

```js
// @flow

function foo(x: ?number): string {
  if (x) {
    return x;
  }
  return "default string";
}
```

* 用 flow 检查类型错误

直接运行 `flow` 即可启动检查程序。

## 类型注释

### Primitive Types

js 拥有几种原始类型：

* Booleans
* Strings
* Numbers
* null
* undefined (在 flow 中是 void)
* Symbols

在代码中它们有时是字面量，有时是包装对象：

```js
//字面量
true;
"hello";
3.14;
null;
undefined;

//包装对象
new Boolean(false);
new String("world");
new Number(42);
```

期望字面值的时候就使用`小写字母`：

```js
// @flow
function method(x: number, y: string, z: boolean) {
  // ...
}

method(3.14, "hello", true);
```

期望包装对象的时候就使用`首字母大写`（和每种原始类型的构造函数一样）：

```js
// @flow
function method(x: Number, y: String, z: Boolean) {
  // ...
}

method(new Number(42), new String("world"), new Boolean(false));
```

包装对象的这种形式很少用得到。

#### Booleans

Boolean 类型在 js 中的值是 `true` 和 `false`。在 flow 中 `boolean` 接受以下几种值得表现：

```js
// @flow
function acceptsBoolean(value: boolean) {
  // ...
}

acceptsBoolean(true);  // Works!
acceptsBoolean(false); // Works!
acceptsBoolean("foo"); // Error!
```

因此，当使用 `boolean` 的时候，flow 需要你显式地将非布尔值转换成布尔值，可以使用 `Boolean(x)` 或者 `!!x`。

```js
// @flow
function acceptsBoolean(value: boolean) {
  // ...
}

acceptsBoolean(0);          // Error!
acceptsBoolean(Boolean(0)); // Works!
acceptsBoolean(!!0);        // Works!
```

注意，flow 中 `boolean` 和 `Boolean` 代表两种不同的类型：

* `boolean` 代表布尔类型字面量，`true` 和 `false`，以及一些表达式的结果，例如 `x === y`
* `Boolean` 代表使用全局构造函数 `new Boolean(x)` 创建的包装对象

#### Numbers

js 只有一种数值类型，`42` 和 `3.14` 都是数值类型，`Infinity` 和 `NaN` 也是。

```js
// @flow
function acceptsNumber(value: number) {
  // ...
}

acceptsNumber(42);       // Works!
acceptsNumber(3.14);     // Works!
acceptsNumber(NaN);      // Works!
acceptsNumber(Infinity); // Works!
acceptsNumber("foo");    // Error!
```

同样，flow 中 `number` 和 `Number` 代表两种不同的类型：

* `number` 代表数值类型字面量，例如 `42` 和 `3.14` 或者一些表达式的结果，例如 `parseFloat(x)`
* `Number` 代表使用全局构造函数 `new Number(x)` 创建的包装对象

#### Strings

字符串类型例如 'foo'，在 flow 中 `string` 如下：

```js
// @flow
function acceptsString(value: string) {
  // ...
}

acceptsString("foo"); // Works!
acceptsString(false); // Error!
```

你必须把非字符串类型显示转换成字符串：

```js
// @flow
"foo" + String({});     // Works!
"foo" + [].toString();  // Works!
"" + JSON.stringify({}) // Works!
```

同样，flow 中 `string` 和 `String` 代表两种不同的类型：

* `string` 代表字符串类型字面量，例如 `"foo"` 或者一些表达式的结果，例如 `"" + 42`
* `String` 代表使用全局构造函数 `new String(x)` 创建的包装对象

#### null 和 void

js 中的 `null` 和 `undefined` 在 flow 中是 `null` 和 `void`

```js
// @flow
function acceptsNull(value: null) {
  /* ... */
}

function acceptsUndefined(value: void) {
  /* ... */
}

acceptsNull(null);      // Works!
acceptsNull(undefined); // Error!
acceptsUndefined(null);      // Error!
acceptsUndefined(undefined); // Works!
```

#### Maybe types

