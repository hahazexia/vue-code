# new Vue()

## initData

先分析下面这个简单的例子是怎么运行的：

```js
// html
<div id="app">
    {{ message }}
</div>

// js
var app = new Vue({
    el: '#app',
    data () {
        return {
            message: 'Hello Vue!'
        }
    }
})

```

再回到 `./src/core/instance/index` 文件，其中有一句：

```js
this._init(options)
```

这个 `_init` 方法是定义在 Vue.prototype 上的方法，由 initMixin 定义，打开 initMixin 的定义，其中有 Vue.prototype._init 的定义，中间有一句:

```js
initState(vm)
```

这个方法调用会初始化 data 数据，并将它变成响应式的。通过 initState 方法的定义打开 initData 方法的定义，可以在其中看到一句：

```js
proxy(vm, `_data`, key)
```

这一句为 Vue 的实例 vm 添加了 _data 属性，并添加了 getter 和 setter 的代理效果：

```js
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

所以当我们使用 `this.a` 的时候，就会调用 getter ，其实调用的是 `this._data.a`，这就是为什么从实例上能够直接访问到 data 属性里的值。

## $mount

在 Vue.prototype._init 中最后，如果传入了 el 参数（页面上的 dom 元素），那么就调用实例的 $mount 方法挂载：

```js
if (vm.$options.el) {
    vm.$mount(vm.$options.el)
}
```

Vue.prototype.$mount 的定义在 `./src/platforms/web/entry-runtime-with-compiler.js` 和  `./src/platforms/web/runtime/index` 里。注意，这里将 $mount 定义了两次，原因是因为 runtime only 的版本和 runtime with compiler 的版本的 $mount 是不一样的，有一些区别，所以会有一次重新定义。

```js
const mount = Vue.prototype.$mount // 将 runtime only 的 $mount 存下，重新定义 $mount ，因为带 compiler 的 $mount 方法与之不同
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el) // query 方法获取到 el 对应的 dom 元素

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) { // 判断 el 对应 dom 元素是否是 html 和 body ，如果是就警告
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) { // 如果没有定义 render 方法
    let template = options.template // template 参数
    if (template) {
      if (typeof template === 'string') { // 如果 template 参数是字符串
        if (template.charAt(0) === '#') { // 如果值以 # 开始，则它将被用作选择符，并使用匹配元素的 innerHTML 作为模板。
          template = idToTemplate(template) // 根据选择符获取元素的 innerHTML
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) { // 如果获取不到元素就警告
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) { // 如果 template 是 dom 节点，直接获取 innerHtml
        template = template.innerHTML
      } else {// template 不是字符串也不是节点，报错返回
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {// 如果没有定义 template 属性，获取字符串形式的 html 片段
      template = getOuterHTML(el)
    }
    if (template) { // 对字符串形式的 template 进行处理，将其变成 render 方法
      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile')
      }

      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render // 添加 template 编译好的 render 方法到 $options 上
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  return mount.call(this, el, hydrating) // 调用 runtime only 时定义的 $mount 方法
}
```

可以看到，Vue.prototype.$mount 所做的操作就是获取 el 参数对应的 dom 元素，然后判断有没有定义 render 函数，如果有 render 函数就直接调用 runtime only 时定义的 $mount，否则就通过 template 参数获取到 dom 元素，然后传递给 compileToFunctions 方法将其转换成 render 函数。有了 render 函数才继续调用 runtime only 时定义的 $mount。

```js
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component { // runtime only 的 $mount 方法
  el = el && inBrowser ? query(el) : undefined // 判断是否是浏览器环境，如果是就获取 el 参数对应的 dom 元素
  return mountComponent(this, el, hydrating)
}
```

`./src/platforms/web/runtime/index` 里的 $mount 调用后，转而去调用 mountComponent 方法。mountComponent 方法里判断 render 函数，如果还没有那么就报错。如果有了，就调用 _render 生成 vnode，调用 _update 更新 vnode。最后将 updateComponent 传递给 Watcher 构造函数新建 wacher 实例，每次数据改变视图需要更新的时候都会被 wacher 发现然后调用 updateComponent。

```js

export function updateChildComponent (
  vm: Component,
  propsData: ?Object,
  listeners: ?Object,
  parentVnode: MountedComponentVNode,
  renderChildren: ?Array<VNode>
) {
  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = true
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  const newScopedSlots = parentVnode.data.scopedSlots
  const oldScopedSlots = vm.$scopedSlots
  const hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  )

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  const needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  )

  vm.$options._parentVnode = parentVnode
  vm.$vnode = parentVnode // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode
  }
  vm.$options._renderChildren = renderChildren

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject
  vm.$listeners = listeners || emptyObject

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false)
    const props = vm._props
    const propKeys = vm.$options._propKeys || []
    for (let i = 0; i < propKeys.length; i++) {
      const key = propKeys[i]
      const propOptions: any = vm.$options.props // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm)
    }
    toggleObserving(true)
    // keep a copy of raw propsData
    vm.$options.propsData = propsData
  }

  // update listeners
  listeners = listeners || emptyObject
  const oldListeners = vm.$options._parentListeners
  vm.$options._parentListeners = listeners
  updateComponentListeners(vm, listeners, oldListeners)

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context)
    vm.$forceUpdate()
  }

  if (process.env.NODE_ENV !== 'production') {
    isUpdatingChildComponent = false
  }
}
```