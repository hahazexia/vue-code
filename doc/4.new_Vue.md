# new Vue()

## initData

先分析下面这个简单的例子是怎么运行的：

```js
// html
<div id="app">
    {{ message }}
</div>

// js
var app = new Vue({
    el: '#app',
    data () {
        return {
            message: 'Hello Vue!'
        }
    }
})

```

再回到 `./src/core/instance/index` 文件，其中有一句：

```js
this._init(options)
```

这个 `_init` 方法是定义在 Vue.prototype 上的方法，由 initMixin 定义，打开 initMixin 的定义，其中有 Vue.prototype._init 的定义，中间有一句:

```js
initState(vm)
```

这个方法调用会初始化 data 数据，并将它变成响应式的。通过 initState 方法的定义打开 initData 方法的定义，可以在其中看到一句：

```js
proxy(vm, `_data`, key)
```

这一句为 Vue 的实例 vm 添加了 _data 属性，并添加了 getter 和 setter 的代理效果：

```js
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

所以当我们使用 `this.a` 的时候，就会调用 getter ，其实调用的是 `this._data.a`，这就是为什么从实例上能够直接访问到 data 属性里的值。

## $mount

在 Vue.prototype._init 中最后，如果传入了 el 参数（页面上的 dom 元素），那么就调用实例的 $mount 方法挂载：

```js
if (vm.$options.el) {
    vm.$mount(vm.$options.el)
}
```

Vue.prototype.$mount 的定义在 `./src/platforms/web/entry-runtime-with-compiler.js` 和  `./src/platforms/web/runtime/index` 里。注意，这里将 $mount 定义了两次，原因是因为 runtime only 的版本和 runtime with compiler 的版本的 $mount 是不一样的，有一些区别，所以会有一次重新定义。

